package IC.Parser;

import IC.AST.*;
import IC.*;
import java.util.List;
import java.util.LinkedList;
import java.util.ArrayList;
import java.util.*;
import java_cup.runtime.*;

//////////////////////////////////////
// User Code

parser code {:

	private Lexer lexer;

	public boolean printToken, classDec;
	private int blockStartLine, classStartLine, blockDepth;
	private HashMap<Integer, Integer> blockLineStack;
	private String syntaxErrorMsg;
	private boolean mathUnaryOpCheck;
	private Type fieldListToken;
	
	public Parser(Lexer lex)
	{
		super(lex);
		lexer = lex;
		blockStartLine = 0;
		classStartLine = 0;
		blockDepth = 0;
		mathUnaryOpCheck = false;
		blockLineStack = new HashMap<>();
	}
	
	public int GetLine()
	{
		return lexer.GetLineNumber();
	}
	
	public int GetColumn()
	{
		return lexer.GetColumnNumber();
	}
	
	public String BuildSyntaxError(Symbol s)
	{
		Token t = ((Token)s) ;
		Helper.BuildNameToValueHM();
		StringBuffer sb = new StringBuffer();
		sb.append(t.getLine() + ":" + t.getColumn() + " : syntax error;");
		List<Integer> expected_ids = expected_token_ids();		
		expected_ids = expected_token_ids();
		expected_ids = expected_token_ids();
		if (expected_ids.size() > 0)
		{
			List<String> expected_tokens = new ArrayList<String>();
			for (int id : expected_ids)
			{
				String tokenRep = Helper.getTokenVbyTokenNFromHM(symbl_name_from_id(id));
				if(tokenRep != null)
					expected_tokens.add(tokenRep);
			}
			Collections.sort(expected_tokens);
			sb.append(" expected '" + expected_tokens.get(0) + "' ");
			for (int i = 1; i < expected_tokens.size(); i++)
			{
					sb.append("or '" + expected_tokens.get(i) + "' ");
			}
			sb.append(", but ");
		}
		else
		{
			expected_ids = expected_token_ids();
			if (expected_ids.size() > 0)
			{
				List<String> expected_tokens = new ArrayList<String>();
				for (int id : expected_ids)
				{
					String tokenRep = Helper.getTokenVbyTokenNFromHM(symbl_name_from_id(id));
					if(tokenRep != null)
						expected_tokens.add(tokenRep);
				}
				Collections.sort(expected_tokens);
				sb.append(" expected '" + expected_tokens.get(0) + "' ");
				for (int i = 1; i < expected_tokens.size(); i++)
				{
					sb.append("or '" + expected_tokens.get(i) + "' ");
				}
				sb.append(", but ");
			}
			else
			{
				expected_ids = expected_token_ids();
				if (expected_ids.size() > 0)
				{
					List<String> expected_tokens = new ArrayList<String>();
					for (int id : expected_ids)
					{
						String tokenRep = Helper.getTokenVbyTokenNFromHM(symbl_name_from_id(id));
						if(tokenRep != null)
							expected_tokens.add(tokenRep);
					}
					Collections.sort(expected_tokens);
					sb.append(" expected '" + expected_tokens.get(0) + "' ");
					for (int i = 1; i < expected_tokens.size(); i++)
					{
						sb.append("or '" + expected_tokens.get(i) + "' ");
					}
					sb.append(", but ");
				}
				else
					sb.append(" Unresolved error, ");				
			}
			
		}
		String tokenRep = Helper.getTokenVbyTokenNFromHM(symbl_name_from_id(t.GetId()));
		if(tokenRep != null)
		{	
			if (t.GetId() != sym.EOF)
				sb.append("found '" + tokenRep + "'");
			else
				sb.append("Got to the end of file");
		}
		else
			sb.append("found unrelated Token");

		return sb.toString();
		
	}
	
	public void syntax_error(Symbol s)
	{
		String msg = BuildSyntaxError(s);
		syntaxErrorMsg = msg;
	}
	
	public void report_fatal_error(String message, Object info) throws SyntaxError
	{
		done_parsing();
		throw new SyntaxError(syntaxErrorMsg);
	}
	
	public void CheckExpressionLiteralInteger(Expression e, boolean pos) throws SyntaxError
	{
		int res = Helper.CheckLiteralInteger(e, pos);
		if (res == 0)
			return;
		Literal l = ((Literal)e);
		if (res == 1)
			syntaxErrorMsg = String.format("%d:%d : syntax error; number %s is bigger than maximum integer (2^31-1)",
				l.getLine(),   l.getColumn(), l.getValue().toString());
		if (res == 2)
			syntaxErrorMsg = String.format("%d:%d : syntax error; number %s is lower than minumin integer (-2^31)",
				l.getLine(),   l.getColumn(), l.getValue().toString());
		
		report_fatal_error("syntax error", e);
	}
	
	public void SetStartLineForMoreThanOneLineStatements(Token t)
	{
		if (t.GetId() == sym.CLASS_ID && classDec)
		{
			classStartLine = t.getLine();
			classDec = false;
		}
		else if (t.GetId() == sym.LBRACE)
		{	
			blockDepth++;
			blockLineStack.put(blockDepth, t.getLine());
		}
	}
	
:};

scan with {:
	
	Token t = lexer.next_token();		
	
	if (t.GetId() == sym.CLASS)
		classDec = true;
	
	SetStartLineForMoreThanOneLineStatements(t);
	
	if (printToken)
	{
		if (t.id == sym.EOF)
			System.out.println("Token : EOF");
		else
			System.out.println("Token : " + t);
	}
	return t;
	
:}


////////////////////////////////////////////
// Symbol list (terminals and non-terminals)

terminal Assignment			ASSIGN;
terminal BinaryOps			GT, LT, EQEQ, LTEQ, GTEQ, NOTEQ, ANDAND, OROR;
terminal BinaryOps			PLUS, MINUS, MULT, DIV, REMAINDER;
terminal UnaryOps			UMINUS, NOT;
terminal String				INTEGER_L, STRING_L, TRUE_BOOLEAN, FALSE_BOOLEAN, NULL;
terminal String				ID, CLASS_ID;
terminal String				LPAREN, RPAREN, LBRACE, RBRACE, LBRACK, RBRACK, SEMICOLON, COMMA, DOT;
terminal String				BOOLEAN, BREAK, CLASS, CONTINUE, ELSE, EXTENDS;
terminal String				INT, NEW, IF, RETURN, VOID, STATIC, WHILE;
terminal String				THIS, QUOTE, LENGTH;

non terminal Program			Program;
non terminal List<ICClass>		ClassListDecl;
non terminal ICClass			ClassDecl;
non terminal FieldOrMethod		FieldOrMethod;
non terminal List<Field>		FieldList, FieldListMore;
non terminal Field				Field;
non terminal Method				MethodDecl, Method;
non terminal Type				Type, Identifier, VoidType;
non terminal List<Formal>		FormalsList;
non terminal List<Formal>		Formals;
non terminal List<Statement>	StmtList;
non terminal Statement			Stmt, IfStmt, StmtClose, StmtOpen, StmtSemiCo;
non terminal Expression			Expr;
non terminal Call				Call;
non terminal StaticCall			StaticCall;
non terminal VirtualCall		VirtualCall;
non terminal List<Expression>	ArgList;
non terminal Location			Location;
non terminal BinaryOps			MathBinOpLow, MathBinOpHigh, RelationalBinOp, EqualityBinOp;
non terminal UnaryOps			LogicalUnOp, MathUnOp;
non terminal Literal			Literal;

//////////////////////////
// Precedence declarations

precedence left RBRACE;
//precedence left INT, COMMA;
precedence left ID;
precedence right ASSIGN;
precedence left OROR;
precedence left ANDAND;
precedence left EQEQ, NOTEQ;
precedence left LT, LTEQ, GT, GTEQ;
precedence left PLUS, MINUS;
precedence left MULT, DIV, REMAINDER;
precedence right UMINUS, NOT;
precedence left LBRACK, RBRACK, LPAREN, RPAREN, DOT;

//////////////
// The grammar

start with Program;

Program			::=		ClassListDecl:cld
						{:	RESULT = new Program(cld); :} 
					| 	
						{:	RESULT = new Program(new LinkedList<ICClass>()); :}
					;

ClassListDecl	::=		ClassDecl:cd
						{:	
							RESULT = new LinkedList<ICClass>();
							RESULT.add(cd);
						:}	 
					|	ClassListDecl:cld ClassDecl:cd
						{:
							cld.add(cd);
							RESULT = cld;
						:}
					;

ClassDecl		::= 	CLASS CLASS_ID:cid LBRACE FieldOrMethod:ic RBRACE
						{:	
							RESULT = new ICClass(classStartLine, cid, ic.GetFields(), ic.GetMethods());
						:}
					
					|	CLASS CLASS_ID:cid EXTENDS CLASS_ID:cidex LBRACE FieldOrMethod:ic RBRACE
						{:	RESULT = new ICClass(classStartLine, cid, cidex, ic.GetFields(), ic.GetMethods()); :}
											
					;
					
FieldOrMethod	::=		/*	Empty */
						{:	RESULT = new FieldOrMethod(); :}


					|	MethodDecl:mtd FieldOrMethod:fom
						{:
							fom.AddMethod(mtd);	
							RESULT = fom;
						:}
					
					|	FieldList:fld FieldOrMethod:fom 
						{:
							fom.AddFields(fld);
							RESULT = fom;	
						:}
																
					;
					
MethodDecl		::=		Method:m
						{:	RESULT = m; :}

					|	STATIC Method:m
						{:	RESULT = new StaticMethod(m.getType(), m.getName(), m.getFormals(), m.getStatements()); :}
														
					;					

Method			::=		Type:t ID:id LPAREN FormalsList:fl RPAREN LBRACE StmtList:stl RBRACE
						{:	
							RESULT = new VirtualMethod(t, id, fl, stl); 
						:}
						
					|	VoidType:v ID:id LPAREN FormalsList:fl RPAREN LBRACE StmtList:stl RBRACE
						{:	
							RESULT = new VirtualMethod(v, id, fl, stl);
						:}
						
					;

VoidType		::=		VOID
						{:	RESULT = new PrimitiveType(parser.GetLine(), DataTypes.VOID); :}
					
					;

FieldList		::=		Field:f FieldListMore:flm SEMICOLON
						{:	
							flm.add(0, f);
							RESULT = flm;
						:}

					;

FieldListMore	::=		COMMA ID:id FieldListMore:fl
						{:
							Field f = new Field(fieldListToken, id);
							fl.add(0, f);
							RESULT = fl;
						:}
					
					|	/* empty */
						{:	RESULT = new LinkedList<Field>(); :}
					
					;

Field			::=		Type:t ID:id
						{:	
							fieldListToken = t;	
							RESULT = new Field(t, id); 
						:}
					
					;
					 					
FormalsList		::=		Type:t ID:id Formals:f
						{: 
							Formal fn = new Formal(t, id);
							f.add(0, fn);
							RESULT = f; 
						:}
						 
					|	/* empty */
						{:	RESULT = new LinkedList<Formal>(); :}
					;

Formals			::=		COMMA Type:t ID:id Formals:f 
						{:	
							Formal fn = new Formal(t, id);
							f.add(0, fn);
							RESULT = f; 
						:}
					
					|	/* empty */
						{: RESULT = new LinkedList<Formal>(); :}
					;


Type			::=		Identifier:i
						{:	RESULT = i; :}
						
					|	Type:t LBRACK RBRACK
						{:
							t.incrementDimension();	
							RESULT = t; 
						:}
					;

Identifier		::=		INT 
						{: RESULT = new PrimitiveType(parser.GetLine(), DataTypes.INT); :}
						
					|	BOOLEAN
						{: RESULT = new PrimitiveType(parser.GetLine(), DataTypes.BOOLEAN); :}
						 
					|	STRING
						{: RESULT = new PrimitiveType(parser.GetLine(), DataTypes.QUOTE); :}
						
					|	CLASS_ID:cid
						{: RESULT = new UserType(parser.GetLine(), cid); :}
					
					;

StmtList		::=		Stmt:s StmtList:sl
						{:	
							sl.add(s);
							RESULT = sl;
						:}
					
					|	/* empty */
						{: RESULT = new LinkedList<Statement>(); :}
					
					;

Stmt			::=		StmtClose:sc
						{:	RESULT = sc; :}
					
					|	StmtOpen:so
						{:	RESULT = so; :} 
					
					|	Type:t ID:id SEMICOLON
						{:	RESULT = new LocalVariable(t, id); :}
					
					;

StmtOpen		::=		IF LPAREN Expr:e RPAREN IfStmt:s
						{:	RESULT = new If(e, s); :}
						
					|	IF LPAREN Expr:e RPAREN StmtClose:s ELSE StmtOpen:se
						{:	RESULT = new If(e, s, se); :}
						
					|	WHILE LPAREN Expr:e RPAREN StmtOpen:s
						{:	RESULT = new While(e, s); :}

					;

StmtClose		::=		IF LPAREN Expr:e RPAREN StmtClose:s ELSE StmtClose:se
						{:	RESULT = new If(e, s, se); :}
												
					|	WHILE LPAREN Expr:e RPAREN StmtClose:s
						{:	RESULT = new While(e, s); :}
											
					|	LBRACE StmtList:sl RBRACE
						{:	
							int blockLine = blockLineStack.get(blockDepth);
							blockDepth--;
							RESULT = new StatementsBlock(blockLine, sl); 
						:}
						
					|	LBRACE RBRACE
						{:
							int blockLine = blockLineStack.get(blockDepth);
							blockDepth--;								
							RESULT = new StatementsBlock(blockLine, new LinkedList<Statement>());	
						:}
						
					|	StmtSemiCo:s SEMICOLON											
						{:	RESULT = s; :}
					;

StmtSemiCo		::=		Location:l ASSIGN Expr:e
						{:	RESULT = new Assignment(l, e); :}
						
					|	Call:c
						{:	RESULT = new CallStatement(c); :}
					
					|	RETURN
						{:	RESULT = new Return(GetLine()); :}
						
					|	RETURN Expr:e
						{:	RESULT = new Return(e.getLine(), e); :}

					|	BREAK
						{:	RESULT = new Break(GetLine()); :}
						
					|	CONTINUE
						{:	RESULT = new Continue(GetLine()); :}

					|	Type:t ID:id ASSIGN Expr:e
						{:	RESULT = new LocalVariable(t, id, e); :}

					;

IfStmt			::=		StmtClose:sc
						{:	RESULT = sc; :}
					
					|	StmtOpen:so
						{:	RESULT = so; :}
						
					;

Expr			::=		Location:l
						{:	RESULT = l; :}
					
					|	Call:c
						{:	RESULT = c; :}
						 
					|	THIS
						{:	RESULT = new This(parser.GetLine()); :}
					
					|	NEW CLASS_ID:id LPAREN RPAREN
						{:	RESULT = new NewClass(parser.GetLine(), id); :}
						
					|	NEW Type:t LBRACK Expr:e RBRACK
						{:	RESULT = new NewArray(t, e); :} %prec LBRACK
						
					|	Expr:e DOT LENGTH
						{:	RESULT = new Length(e); :} %prec DOT
						
					|	Expr:e1 RelationalBinOp:lbo Expr:e2
						{:	RESULT = new LogicalBinaryOp(e1, lbo, e2); :} %prec LT
					
					|	Expr:e1 EqualityBinOp:lbo Expr:e2
						{:	RESULT = new LogicalBinaryOp(e1, lbo, e2); :} %prec EQEQ
						
					|	Expr:e1 ANDAND Expr:e2
						{:
							BinaryOps b = BinaryOps.LAND;	
							RESULT = new LogicalBinaryOp(e1, b, e2); 
						:} %prec ANDAND
						
					|	Expr:e1 OROR Expr:e2
						{:
							BinaryOps b = BinaryOps.LOR;	
							RESULT = new LogicalBinaryOp(e1, b, e2); 
						:} %prec OROR
						
					|	Expr:e1 MathBinOpLow:mbo Expr:e2
						{:	RESULT = new MathBinaryOp(e1, mbo, e2); :} %prec PLUS
					
					|	Expr:e1 MathBinOpHigh:mbo Expr:e2
						{:	RESULT = new MathBinaryOp(e1, mbo, e2); :} %prec MULT
						
					|	LogicalUnOp:luo Expr:e
						{:	RESULT = new LogicalUnaryOp(luo, e); :} %prec NOT
					
					|	MathUnOp:muo Expr:e
						{:	
							CheckExpressionLiteralInteger(e, false);
							mathUnaryOpCheck = false;
							RESULT = new MathUnaryOp(muo, e); 
						:}	%prec UMINUS
					
					|	Literal:l
						{:	
							if (!mathUnaryOpCheck)
								CheckExpressionLiteralInteger(l, true);
							RESULT = l; 
						:}
						
					|	LPAREN Expr:e RPAREN
						{:	RESULT = new ExpressionBlock(e); :} %prec LPAREN
					
					;

Call			::=		StaticCall:sc
						{:	RESULT = sc; :}
						
					|	VirtualCall:vc
						{:	RESULT = vc; :}

					;

StaticCall		::=		CLASS_ID:cid DOT ID:id LPAREN ArgList:al RPAREN
						{:	RESULT = new StaticCall(parser.GetLine(), cid, id, al); :}
					|	CLASS_ID:cid DOT ID:id LPAREN RPAREN
						{:	RESULT = new StaticCall(parser.GetLine(), cid, id, new LinkedList<Expression>()); :}
					
					;

VirtualCall		::=		ID:id LPAREN ArgList:al RPAREN
						{:	RESULT = new VirtualCall(parser.GetLine(), id, al); :}
						
					|	ID:id LPAREN RPAREN
						{:	RESULT = new VirtualCall(parser.GetLine(), id, new LinkedList<Expression>()); :}
						
					|	Expr:e DOT ID:id LPAREN ArgList:al RPAREN
						{:	RESULT = new VirtualCall(parser.GetLine(), e, id, al); :}
						
					|	Expr:e DOT ID:id LPAREN RPAREN
						{:	RESULT = new VirtualCall(parser.GetLine(), e, id, new LinkedList<Expression>()); :}
					;

ArgList			::=		Expr:e
						{:
							RESULT = new LinkedList<Expression>();
							RESULT.add(0, e);
						:}
					|	Expr:e COMMA ArgList:al
						{:
							al.add(0, e);
							RESULT = al;
						:}
					
					;

Location		::=		ID:id
						{:	RESULT = new VariableLocation(parser.GetLine(), id); :}
						
					|	Expr:e DOT ID:id
						{:	RESULT = new VariableLocation(parser.GetLine(), e, id); :}
						 
					|	Expr:e1 LBRACK Expr:e2 RBRACK
						{:	RESULT = new ArrayLocation(e1, e2); :}
					
					;

RelationalBinOp	::=		LT
						{:	RESULT = BinaryOps.LT; :} %prec LT
						
					|	LTEQ
						{:	RESULT = BinaryOps.LTE; :} %prec LTEQ
						
					|	GT
						{:	RESULT = BinaryOps.GT; :} %prec GT
						
					|	GTEQ
						{:	RESULT = BinaryOps.GTE; :} %prec GTEQ

					;
					
EqualityBinOp	::=		EQEQ
						{:	RESULT = BinaryOps.EQUAL; :} %prec EQEQ
						
					|	NOTEQ
						{:	RESULT = BinaryOps.NEQUAL; :} %prec NOTEQ

					;
					
MathBinOpLow	::=		PLUS
						{:	RESULT = BinaryOps.PLUS; :} %prec PLUS
						
					|	MINUS
						{:	RESULT = BinaryOps.MINUS; :} %prec MINUS
						
					;
					
MathBinOpHigh	::=		MULT
						{:	RESULT = BinaryOps.MULTIPLY; :} %prec MULT
						
					|	DIV
						{:	RESULT = BinaryOps.DIVIDE; :} %prec DIV
						
					|	REMAINDER
						{:	RESULT = BinaryOps.MOD; :} %prec REMAINDER
					;

LogicalUnOp		::=		NOT
						{:	RESULT = UnaryOps.LNEG; :} %prec NOT
					
					;

MathUnOp		::=		MINUS
						{:
							mathUnaryOpCheck = true;	
							RESULT = UnaryOps.UMINUS; 
						:}
						
					;

Literal			::=		INTEGER_L:i
						{:	RESULT = new Literal(GetLine(), GetColumn(), LiteralTypes.INTEGER, i); :}
						
					|	STRING_L:s
						{:	RESULT = new Literal(GetLine(), LiteralTypes.QUOTE, s.substring(1, s.length() - 1)); :}
						
					|	TRUE_BOOLEAN
						{:	RESULT = new Literal(GetLine(), LiteralTypes.TRUE); :}
						
					|	FALSE_BOOLEAN
						{:	RESULT = new Literal(GetLine(), LiteralTypes.FALSE); :}
						
					|	NULL
						{:	RESULT = new Literal(GetLine(), LiteralTypes.NULL); :}
					
					;
